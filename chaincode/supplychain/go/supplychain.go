package main

import (
	"fmt"
	"encoding/json"
	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

// ServerConfig for external chaincode
type ServerConfig struct {
	CCID string
	Address string
}

// SmartContract provides functions for managing rubber supply chain
type SmartContract struct {
	contractapi.Contract
}

// RubberCert describes basic details of rubber supply chain management
type RubberCert struct {
	Type string `json:"type"`
	Hardness string `json:"hardness"`
	TensileStrength int `json:"tensileStrength"`
	RubberCertHolder string `json:"rubberCertHolder"`
	Weight int `json:"weight"`
	Buyer string `json:"buyer"`
	Date string `json:"dateOfIssueRubberCert"`
}

// QueryRubberCert struct used for handling result of query
type QueryRubberCert struct {
	Key string `json:"rubberCertKey"`
	Cert *RubberCert
}

// ShippingBill describes basic details of bill generated by shipper
type ShippingBill struct {
	ShippingCost int `json:"shippingCost"`
	Address string `json:"address"`
	EstimatedDeliveryDate string `json:"estimatedDeliveryDate"`
	BillHolder string `json:"billHolder"`
}

// QueryShippingBill struct used to handle result query
type QueryShippingBill struct {
	Key string `json:"ShippingBillKey"`
	Bill *ShippingBill
}

// ApprovalCert describes basic details of approval certificate from custom
type ApprovalCert struct {
	Status string `json:"status"`
	Date string `json:"dateofIssueCustomCert"`
	ApprovalCertHolder string `json:"approvalCertHolder"`
}

// QueryApprovalCert struct used to handle result query
type QueryApprovalCert struct {
	Key string `json:"ApprovalCertKey"`
	Cert *ApprovalCert
}

// QueryRubberCertAndShippingBillAndApprovalCert is the combination of rubber certificate and respective shipping bill
type QueryRubberCertAndShippingBillAndApprovalCert struct{
	RubberCert *RubberCert
	Bill *ShippingBill
	ApprovalCert *ApprovalCert
}

// GenerateRubberCert creates the certificate of rubber batch manufactured by IndonesianFarm
func (s *SmartContract) GenerateRubberCert(ctx contractapi.TransactionContextInterface, rubberBatchNumber string, rubberType string, hardness string, tensileStrength int, rubberCertHolder string, weight int, buyer string, date string) error {
	rubberCert := RubberCert{
		Type: rubberType,
		Hardness: hardness,
		TensileStrength: tensileStrength,
		RubberCertHolder: rubberCertHolder,
		Weight: weight,
		Buyer: buyer,
		Date: date,
	}

	rubberCertAsBytes, _ := json.Marshal(rubberCert)

	return ctx.GetStub().PutState(rubberBatchNumber, rubberCertAsBytes)
}

// QueryGeneratedRubberCert returns the batch of rubber stored in the world state with given rubber batch number
func (s *SmartContract) QueryGeneratedRubberCert(ctx contractapi.TransactionContextInterface, rubberBatchNumber string) (*RubberCert, error) {
	rubberCertAsBytes, err := ctx.GetStub().GetState(rubberBatchNumber)
	
	if err != nil {
		return nil, fmt.Errorf("Failed to read from world state. %s", err.Error())
	}

	if rubberCertAsBytes == nil {
		return nil, fmt.Errorf("%s does not exist", rubberBatchNumber)
	}

	rubberCert := new(RubberCert)
	_ = json.Unmarshal(rubberCertAsBytes, rubberCert)

	return rubberCert, nil
}

// QueryAllGeneratedRubberCerts returns all generated certificates of all rubber batch found in world state
func (s *SmartContract) QueryAllGeneratedRubberCerts(ctx contractapi.TransactionContextInterface) ([]QueryRubberCert, error) {
	startKey := ""
	endKey := ""

	resultsIterator, err := ctx.GetStub().GetStateByRange(startKey, endKey)

	if err != nil {
		return nil, err
	}
	defer resultsIterator.Close()

	results := []QueryRubberCert{}

	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()

		if err != nil {
			return nil, err
		}

		rubberCert := new(RubberCert)
		_ = json.Unmarshal(queryResponse.Value, rubberCert)

		queryRubberCert := QueryRubberCert{Key: queryResponse.Key, Cert: rubberCert}
		results = append(results, queryRubberCert)
	}

	return results, nil
}

// TransferRubberCert changes the holder of rubber certificate
func (s *SmartContract) TransferRubberCert(ctx contractapi.TransactionContextInterface, rubberBatchNumber string, newRubberCertHolder string) error {
	rubberCert, err := s.QueryGeneratedRubberCert(ctx, rubberBatchNumber)

	if err != nil {
		return err
	}

	if rubberCert.RubberCertHolder != "indonesian farm" {
		return fmt.Errorf("Invalid certificate holder of %s", rubberBatchNumber)
	}

	rubberCert.RubberCertHolder = newRubberCertHolder

	rubberCertAsBytes, _ := json.Marshal(rubberCert)

	return ctx.GetStub().PutState(rubberBatchNumber, rubberCertAsBytes)
}

// GenerateShippingBill adds shipping bill to the world state with given details after verifying the holder of rubber certificate 
func (s *SmartContract) GenerateShippingBill(ctx contractapi.TransactionContextInterface, rubberBatchNumber string, billNumber string, shippingCost int, address string, estimatedDeliveryDate string) error {
	rubberCert, err := s.QueryGeneratedRubberCert(ctx, rubberBatchNumber)

	if err != nil {
		return err
	}

	if rubberCert.RubberCertHolder != "rubber shipper" {
		return fmt.Errorf("Invalid certificate holder of %s", rubberBatchNumber)
	}

	rubberCertHolder := rubberCert.RubberCertHolder

	bill := ShippingBill{
		ShippingCost: shippingCost,
		Address: address,
		EstimatedDeliveryDate: estimatedDeliveryDate,
		BillHolder: rubberCertHolder,
	}

	billAsBytes, _ := json.Marshal(bill)

	return ctx.GetStub().PutState(billNumber, billAsBytes)
}

// QueryGeneratedShippingBill returns the bill stored in the world state with given rubber batch number
func (s *SmartContract) QueryGeneratedShippingBill(ctx contractapi.TransactionContextInterface, rubberBatchNumber string, billNumber string) (*ShippingBill, error) {
	rubberCert, err := s.QueryGeneratedRubberCert(ctx, rubberBatchNumber)

	if err != nil {
		return nil, err
	}

	billAsBytes, err1 := ctx.GetStub().GetState(billNumber)

	if err1 != nil {
		return nil, fmt.Errorf("Failed to read from world state. %s", err.Error())
	}

	if billAsBytes == nil {
		return nil, fmt.Errorf("%s does not exist", billNumber)
	}

	bill := new(ShippingBill)
	_ = json.Unmarshal(billAsBytes, bill)

	if rubberCert.RubberCertHolder != bill.BillHolder {
		return nil ,fmt.Errorf("Invalid certificate holder of %s", rubberBatchNumber)
	}

	return bill, nil
}

// TransferRubberCertAndShippingBill updates the holder of the rubber certificate and shipping bill
func (s *SmartContract) TransferRubberCertAndShippingBill(ctx contractapi.TransactionContextInterface, rubberBatchNumber string, billNumber string, newBillHolder string) (error, error) {
	rubberCert, err := s.QueryGeneratedRubberCert(ctx, rubberBatchNumber)
	
	if err != nil {
		return err, nil
	}

	bill, err2 := s.QueryGeneratedShippingBill(ctx, rubberBatchNumber, billNumber)

	if err2!= nil {
		return nil, err2
	}

	if rubberCert.RubberCertHolder != bill.BillHolder {
		return nil, fmt.Errorf("Invalid certificate holder of %s", rubberBatchNumber)
	}

	rubberCert.RubberCertHolder = newBillHolder
	bill.BillHolder = newBillHolder

	rubberCertAsBytes, _ := json.Marshal(rubberCert)
	billAsBytes, _ := json.Marshal(bill)

	return ctx.GetStub().PutState(rubberBatchNumber, rubberCertAsBytes), ctx.GetStub().PutState(billNumber, billAsBytes)
}

// GenerateApprovalCert adds approval certificate to the world state with given details
func (s *SmartContract) GenerateApprovalCert(ctx contractapi.TransactionContextInterface, rubberBatchNumber string, billNumber string, approvalCertNumber string, status string, date string, approvalCertHolder string) error {

	bill, err := s.QueryGeneratedShippingBill(ctx, rubberBatchNumber, billNumber)

	if err != nil {
		return err
	}

	approvalCert := ApprovalCert{
		Status: status,
		Date: date,
		ApprovalCertHolder: approvalCertHolder,
	}

	if bill.BillHolder != approvalCert.ApprovalCertHolder {
		return fmt.Errorf("Invalid certificate holder of %s", approvalCertNumber)
	}

	approvalCertAsBytes, _ := json.Marshal(approvalCert)

	return ctx.GetStub().PutState(approvalCertNumber ,approvalCertAsBytes)
}

// QueryGeneratedApprovalCert returns the approval certificate stored in the world state with given approval certificate key
func (s *SmartContract) QueryGeneratedApprovalCert(ctx contractapi.TransactionContextInterface, rubberBatchNumber string, billNumber string, approvalCertNumber string) (*ApprovalCert, error) {
	bill, err := s.QueryGeneratedShippingBill(ctx, rubberBatchNumber, billNumber)

	if err != nil {
		return nil, err
	}

	approvalCertAsBytes, err3 := ctx.GetStub().GetState(approvalCertNumber)

	if err3 != nil {
		return nil, fmt.Errorf("Failed to read from world state. %s", err.Error())
	}

	if approvalCertAsBytes == nil {
		return nil, fmt.Errorf("%s does not exist", approvalCertNumber)
	}

	approvalCert := new(ApprovalCert)
	_ = json.Unmarshal(approvalCertAsBytes, approvalCert)

	if bill.BillHolder != approvalCert.ApprovalCertHolder{
		return nil, fmt.Errorf("Invalid certificate holder of %s", billNumber)
	}

	return approvalCert, nil
}

// TransferRubberCertAndShippingBillAndApprovalCert updates the approval certificate holder with given 
func (s *SmartContract) TransferRubberCertAndShippingBillAndApprovalCert(ctx contractapi.TransactionContextInterface, rubberBatchNumber string, billNumber string, approvalCertNumber string, newApprovalHolder string) error {
	rubberCert, err := s.QueryGeneratedRubberCert(ctx, rubberBatchNumber)

	if err != nil {
		return err
	}

	bill, err2 := s.QueryGeneratedShippingBill(ctx, rubberBatchNumber, billNumber)

	if err2 != nil {
		return err2
	}

	approvalCert, err3:= s.QueryGeneratedApprovalCert(ctx, rubberBatchNumber, billNumber, approvalCertNumber)

	if err3 != nil {
		return err3
	}

	rubberCert.RubberCertHolder = newApprovalHolder
	bill.BillHolder = newApprovalHolder
	approvalCert.ApprovalCertHolder = newApprovalHolder

	rubberCertAsBytes, _ := json.Marshal(rubberCert)
	billAsBytesNew, _ := json.Marshal(bill)
	approvalCertAsBytes, _ := json.Marshal(approvalCert)


	err4 := ctx.GetStub().PutState(rubberBatchNumber ,rubberCertAsBytes)

	returnErr := new(error)
	if err4 != nil {
		returnErr = &err4
	}

	err5 := ctx.GetStub().PutState(billNumber ,billAsBytesNew)

	if err5 != nil && err4 != nil{
		returnErr = &err5
	}

	err6 := ctx.GetStub().PutState(approvalCertNumber ,approvalCertAsBytes)

	if err6 != nil && err5 != nil && err4 != nil {
		returnErr = &err6
	}

	return *returnErr
}

// GetAllDocs returns all three documents (rubber certificate, shipping bill and approval certificate) to the importer
func (s *SmartContract) GetAllDocs(ctx contractapi.TransactionContextInterface, rubberBatchNumber string, billNumber string, approvalCertNumber string) (*QueryRubberCertAndShippingBillAndApprovalCert, error) {
	rubberCert, err := s.QueryGeneratedRubberCert(ctx, rubberBatchNumber)
	
	if err != nil {
		return nil, err
	}

	bill, err2 := s.QueryGeneratedShippingBill(ctx, rubberBatchNumber, billNumber)

	if err2 != nil {
		return nil, err2
	}

	approvalCert, err3 := s.QueryGeneratedApprovalCert(ctx, rubberBatchNumber, billNumber, approvalCertNumber)

	if err3 != nil {
		return nil, err3
	}

	allDocs := new(QueryRubberCertAndShippingBillAndApprovalCert)
	allDocs.RubberCert = rubberCert
	allDocs.Bill = bill
	allDocs.ApprovalCert = approvalCert

	return allDocs, nil
}

func main() {
	smartContract := new(SmartContract)

	cc, err := contractapi.NewChaincode(smartContract)

	if err != nil {
		panic(err.Error())
	}

	if err := cc.Start(); err != nil {
		panic(err.Error())
	}
}